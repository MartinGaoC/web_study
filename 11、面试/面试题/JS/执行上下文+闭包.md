首先我们知道JS中可以执行的代码主要分为三种全局代码、函数、eval

代码执行可以分为三个阶段 预编译（创建环境）、代码执行、垃圾回收

【如果面试的时候，怕说了过多的内容被面试官，可以直接解释一个函数的执行，无需说整体的】


# 执行上下文栈（ECStack）
* JavaScript 中有三种执行上下文类型。

- 全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
- 函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。
- Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。

* 举个例子，当执行到一个函数的时候就会进行准备工作，这里的准备工作，更专业点的说法就是执行上下文

# 执行上下文
*  所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文，为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：模拟上下文定义执行上下文栈是一个数组

```
 ECStack = []
```

# 执行栈上下文栈（ECStack）
试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：

```
ECStack = [
    globalContext
];

```

# 遇到函数的时候怎么做
* 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：
* 先入后出，底部永远是全局上下文栈
    ```
    // 伪代码

        // fun1()
        ECStack.push(<fun1> functionContext);

        // fun1中竟然调用了fun2，还要创建fun2的执行上下文
        ECStack.push(<fun2> functionContext);

        // 擦，fun2还调用了fun3！
        ECStack.push(<fun3> functionContext);

        // fun3执行完毕
        ECStack.pop();

        // fun2执行完毕
        ECStack.pop();

        // fun1执行完毕
        ECStack.pop();

        // javascript接着执行下面的代码，但是ECStack底层永远有个globalContext


    ```




# 每个执行上下文，都有三个重要的属性
* 变量对象(Variable object，VO)
* 作用域链(Scope chain)
* this
    - this 引用类型变量会先指向栈中的内存地址，内存地址指向堆中的地址
    - 对象中有函数的话，value就是函数的地址
    - 函数在不同环境中执行的时候，this就指向不同的地址
    ```
        ExecutionContext = {
            ThisBinding = <this value>,
            LexicalEnvironment = { ... },
            VariableEnvironment = { ... },
        }
    ```
# 全局上下文-全局变量GO
* 我们先了解一个概念，叫全局对象GO。全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。
* 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，总是在执行上下文栈的栈底，只是在程序销毁的时候才会出栈。这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询


# 上下文的执行过程
* 1、进入执行上下文
* 2、代码执行
* 3、回收阶段
  
* 进入执行上下文
    - 当进入执行上下文时，这时候还没有执行代码， 变量对象会包括：
    - 函数的所有形参 
    - 函数声明
    - 变量声明

* 变量对象的创建过程
 
    1. 全局上下文的变量对象初始化是全局对象
    2. 函数上下文的变量对象初始化只包括 Arguments 对象
    3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值
    4. 在代码执行阶段，会再次修改变量对象的属性值





  
* 作用域链
    - 在上面的静态作用域和动态作用域里面讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

* 函数创建
    - 函数的作用域在函数定义的时候就决定了，这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！





# 闭包

* MDN 闭包定义
* 理论角度上讲：在JS中，每创建一个函数，闭包就会在函数创建的同时被创建出来，可以在一个内层函数中访问到外层函数的作用域
* 实践角度：
    - 即使创建它的上下文已经销毁，它依然存在
    
 在代码中引用了看完上面的知识点之后，我们就很容易总结出来，闭包的原理就是Scope链上的匿名函数的上下文，this的原理是动态绑定的，当前的this指向就是当前的执行上下文，作用域链的原理就是Scope:[AO,...,globalContext.AO],eval不能回收的原理是推不进到AO里面，所以在全局变量，导致无法回收。变量提升的原理就是AO的创建阶段。



