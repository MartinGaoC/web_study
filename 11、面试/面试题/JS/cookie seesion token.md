# Cookie
Cookie 由服务器生成，发送给浏览器，浏览器把 Cookie 以 key-value 形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该 cookie 发送给服务器。由于 cookie 是存在客户端上的，所以浏览器加入了一些限制确保 cookie 不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的 cookie 数量是有限的。
- 最大4k 

本身用于浏览器和 server 通讯。
被“借用”到本地存储来的。
可用 document.cookie = '...' 来修改。

其缺点：

存储大小限制为 4KB。
http 请求时需要发送到服务端，增加请求数量。
只能用 document.cookie = '...' 来修改，太过简陋。


HTML5 专门为存储来设计的，最大可存 5M。
API 简单易用， setItem getItem。
不会随着 http 请求被发送到服务端。

它们的区别：

localStorage 数据会永久存储，除非代码删除或手动删除。
sessionStorage 数据只存在于当前会话，浏览器关闭则清空。
一般用 localStorage 会多一些。

# Session
session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢?对方肯定有某种特征(长相等)表明他就是张三。

session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，一般都默认采用 cookie 的方式。

服务器使用 session 把用户的信息临时保存在了服务器上，用户离开网站后 session 会被销毁。这种用户信息存储方式相对 cookie 来说更安全，可是 session 有一个缺陷：如果 web 服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候 session 会丢失。

# Token
在 Web 领域基于 Token 的身份验证随处可见。在大多数使用 Web API 的互联网公司中，Token 是多用户下处理认证的最佳方式。

Token 的起源
基于服务器的验证：

我们都是知道 HTTP 协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。在这之前，程序都是通过在服务端存储的登录信息来辦别请求的。这种方式一般都是通过存储 Session 来完成。

随着 Web，应用程序，移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。

基于服务器验证方式暴露的一些问题：

Seesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。 当越来越多的用户发请求时，内存的开销也会不断增加。

可扩展性：在服务端的内存中使用 Session 存储登录信息，伴随而来的是可扩展性问题。

CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用 Ajax 抓取另一个域的资源，会出现禁止请求的情况。

CSRF(跨站请求伪造)：用户在访问银行网站时,他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。

基于Token的验证原理：

基于 Token 的身份验证是无状态的，我们不将用户信息存在服务器或 Session 中。这种概念解决了在服务端存储信息时的许多问题。