# HTTP

* HTTP之前拨号上网
* TCP/IP  1971
* SMTP 收发邮件
* FTP 传输文件
* Telent 远程登录


# 状态码分类

* 1xx 服务器收到请求
* 2xx 请求成功
* 3xx 重定向 302
* 4xx 客户端错误 404
* 5xx 服务端错误

* 200 成功
* 301 永久重定向
* 302 临时重定向
* 304 缓存，资源未修改
* 403 没权限
* 404 找不到资源
* 500 服务器错误
* 504 服务器资源不存在
* 504 网关超时


# http缓存
* 强缓存 缓存在本地 从本地读取
    - 通过Cache-Control进行逻辑控制
        - max-age：缓存最大过期时间。
        - no-cache：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。
        - no-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源。
* 协商缓存 服务器返回304
    - 服务器通过请求头中的IF-Modified-Since或者If-None-Match这些条件请求字段检查资源是否更新
    - 服务端缓存策略。
    - 服务端判断客户端资源，是否和服务端资源一样。
    - 一致则返回 304，否则返回 200 和最新的资源。
* 代理缓存
    - 源服务器的缓存服务器Redis，如何判断去缓存中获取，一部分是源服务器控制 一部分是客户端控制
    - 源服务器响应头通过Cache-Control这个字段进行控制
    - must-revalidate意思客户端缓存过期就去源服务器取
    - proxy-revalidate代表代理服务器缓存过期到源服务器取

* 三种刷新操作对 http 缓存的影响

    - 正常操作：地址栏输入 url，跳转链接，前进后退等。
    - 手动刷新：f5，点击刷新按钮，右键菜单刷新。
    - 强制刷新：ctrl + f5，shift+command+r。

    - 正常操作：强制缓存有效，协商缓存有效。
    - 手动刷新：强制缓存失效，协商缓存有效。
    - 强制刷新：强制缓存失效，协商缓存失效。



# http请求方法
* get 获取资源
* post 提交数据
* put 修改数据
* DELETE 删除数据
* OPTIONS 列出请求方法
* CONNECT 建立连接隧道
* TRACE 追踪请求

# get和post的区别
* 从缓存的角度，get会被浏览器缓存、post默认不会
* 从编码的角度，get只能进行url编码，只能接受Ascll字符，post没有限制
* 从参数的角度，get只放在url中，因此不安全，post放在请求体中，适合传输敏感信息
* 幂等性的角度，GET是幂等的，post不是
* 从TCP的角度，get只发送一个包，post是两个


# HTTP/2 有哪些改进？（很大可能问原理）

* 头部压缩。
* 多路复用。
* 服务器推送。

# HTTPS原理