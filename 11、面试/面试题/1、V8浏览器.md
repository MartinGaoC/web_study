### 编译性语言
* 程序执行前必须要有编译的过程
* 代表 C++ Java

### 解释性语言
* 支持动态类型、弱类型，程序运行的时候才进行编译，编译前需要确认变量的类型，效率低，兼容性强
* 代表 Python Javascript

* 以上说明，JS属于解释性语言，运行效率低，随着发展，js的应用早超过了表单验证的领域。所以需要解决这个问题。提高运行效率。

### V8引擎
* 一个JS引擎，最初一群语言专家设计，后被谷歌收购开源
* 使用C++开发
* 运行时 其他引擎转换为字节码执行，V8将其编译为原生机器码执行，并使用内联缓存提高性能

* 有了以上优化，V8引擎运行JS的速度媲美二进制。并支持众多系统。Linux Android Ios





### 垃圾回收机制



有两种垃圾回收策略：

* 标记清除：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。
* 引用计数：它把对象是否不再需要简化定义为对象有没有其他对象引用到它。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。

标记清除的缺点：

内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。
分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。

解决以上的缺点可以使用 **标记整理（Mark-Compact）算法 **，标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）



* V8的垃圾回收机制主要 基于分代式
  - V8主要把内存分为新生代和老生代
新生代为临时，老生代常驻

新生代使用Cheney算法

把内存一分为二，分为to和from
* 首先在from中进行内存分配
* 当垃圾回收开始的时候，检查from中的存活对象，存活对象复制到to空间中，非存活空间释放
* 复制完成后，双方空间进行对换。

新生代中的对象生命周期短，适合Cheney这类牺牲空间换取时间的算法

* 晋升
* 当一个对象经过多次复制后，会被认为是生命周期较长的对象，放到老生代中。对象从新生代到老生代的过程叫晋升



* 老生代和新生代相比
* 老生代的对象中，活跃的比例比较高，所以不能采用Cheney的算法


* 老生代算法
* Mark-Sweep 标记清除
  - 标记：标记阶段遍历所有对象，并标记活着的
  - 清除：清除阶段，清除没有被标记的
 - 存在内存碎片的问题
* Mark-Compact 标记整理
 - 为了处理内存碎片的问题，差别在 对象标记死亡后，在整理的过程中，活的对象都迁移到一端。移动完成，直接清理掉内存边界






