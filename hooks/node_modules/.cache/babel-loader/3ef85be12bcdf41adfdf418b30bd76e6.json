{"ast":null,"code":"var _jsxFileName = \"/Users/gaochao/Public/web_study/hooks/src/index.js\",\n    _s = $RefreshSig$();\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nlet hookState = []; //存放所有状态的数组，一进来就调用了两次，所以是分别赋值\n\nlet hookIndex = 0; // 索引\n\nfunction useState(initialState) {\n  hookState[hookIndex] = hookState[hookIndex] || initialState;\n  let currentIndex = hookIndex; // 利用闭包的机制, 外层hook会多次渲染 但是我只改变我点击的值得\n\n  function setState(newState) {\n    hookState[currentIndex] = newState;\n    render();\n  }\n\n  return [hookState[hookIndex++], setState];\n}\n\nlet Child = ({\n  data,\n  onButtonClick\n}) => {\n  console.log('Child render');\n  return /*#__PURE__*/_jsxDEV(\"button\", {\n    onClick: () => onButtonClick(),\n    children: data.number\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 19,\n    columnNumber: 10\n  }, this);\n};\n\n_c = Child;\nChild = /*#__PURE__*/React.memo(Child);\n\nfunction useCallback(callback, dependencies) {\n  if (hookState[hookIndex]) {\n    // 不是第一次渲染\n    let [lastCallback, lastDependencies] = hookState[hookIndex];\n    let same = dependencies.every((item, index) => item === lastDependencies[index]); // 判断新值是否等于旧的值 如果等于 就直接用旧的 否则执行新的\n\n    if (same) {\n      hookIndex++;\n      return lastCallback;\n    } else {\n      // 只要有一个依赖的变量不一样\n      hookState[hookIndex++] = [callback, dependencies]; // hookIndex = 3 callback = ()=> setNumber(number+1)\n\n      return callback;\n    }\n  } else {\n    // 第一次渲染\n    hookState[hookIndex++] = [callback, dependencies];\n    return callback;\n  }\n}\n\nfunction useMemo(factory, dependencies) {\n  if (hookState[hookIndex]) {\n    // 不是第一次渲染\n    let [lastMemo, lastDependencies] = hookState[hookIndex];\n    let same = dependencies.every((item, index) => item === lastDependencies[index]); // 判断新值是否等于旧的值 如果等于 就直接用旧的 否则执行新的\n\n    if (same) {\n      hookIndex++;\n      return lastMemo;\n    } else {\n      // 只要有一个依赖的变量不一样\n      let newMemo = factory();\n      hookState[hookIndex++] = [newMemo, dependencies];\n      return newMemo;\n    }\n  } else {\n    // 第一次渲染\n    let newMemo = factory();\n    hookState[hookIndex++] = [newMemo, dependencies];\n    return newMemo;\n  }\n}\n\nlet App = () => {\n  _s();\n\n  let [number, setNumber] = useState(0);\n  let [name, setName] = useState('my');\n  let data = useMemo(() => ({\n    number\n  }), [number]);\n  let addClick = useCallback(() => setNumber(number + 1), [number]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"input\", {\n      value: name,\n      onChange: e => setName(e.target.value)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 67,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Child, {\n      data: data,\n      onButtonClick: addClick\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 68,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n};\n\n_s(App, \"8NOZ3P2Zv/XSY2a6OSx8GIui/wo=\");\n\n_c2 = App;\n\nfunction render() {\n  hookIndex = 0;\n  ReactDOM.render( /*#__PURE__*/_jsxDEV(App, {}, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 74,\n    columnNumber: 19\n  }, this), document.getElementById('root'));\n}\n\nrender();\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"Child\");\n$RefreshReg$(_c2, \"App\");","map":{"version":3,"sources":["/Users/gaochao/Public/web_study/hooks/src/index.js"],"names":["React","ReactDOM","hookState","hookIndex","useState","initialState","currentIndex","setState","newState","render","Child","data","onButtonClick","console","log","number","memo","useCallback","callback","dependencies","lastCallback","lastDependencies","same","every","item","index","useMemo","factory","lastMemo","newMemo","App","setNumber","name","setName","addClick","e","target","value","document","getElementById"],"mappings":"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","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\n\nlet hookState = [] //存放所有状态的数组，一进来就调用了两次，所以是分别赋值\nlet hookIndex = 0 // 索引\nfunction useState (initialState){\n  hookState[hookIndex] = hookState[hookIndex] || initialState\n  let currentIndex = hookIndex  // 利用闭包的机制, 外层hook会多次渲染 但是我只改变我点击的值得\n  function setState (newState){\n\n    hookState[currentIndex] = newState\n    render()\n  }\n  return [hookState[hookIndex++], setState]\n}\n\nlet Child = ({data, onButtonClick}) =>{\n  console.log('Child render')\n  return <button onClick={()=>onButtonClick()}>{data.number}</button>\n}\n\nChild = React.memo(Child)\n\nfunction useCallback(callback, dependencies){\n  if(hookState[hookIndex]){ // 不是第一次渲染\n    let [lastCallback, lastDependencies] = hookState[hookIndex]\n    let same = dependencies.every((item, index) => item === lastDependencies[index]) // 判断新值是否等于旧的值 如果等于 就直接用旧的 否则执行新的\n    if(same){\n      hookIndex++\n      return lastCallback\n    } else { // 只要有一个依赖的变量不一样\n      hookState[hookIndex++] = [callback, dependencies] // hookIndex = 3 callback = ()=> setNumber(number+1)\n      return callback\n    }\n  } else { // 第一次渲染\n    hookState[hookIndex++] = [callback, dependencies]\n    return callback\n  }\n}\n\nfunction useMemo(factory, dependencies){\n  if(hookState[hookIndex]){ // 不是第一次渲染\n    let [lastMemo, lastDependencies] = hookState[hookIndex]\n    let same = dependencies.every((item, index) => item === lastDependencies[index]) // 判断新值是否等于旧的值 如果等于 就直接用旧的 否则执行新的\n    if(same){\n      hookIndex++\n      return lastMemo\n    } else { // 只要有一个依赖的变量不一样\n      let newMemo = factory()\n      hookState[hookIndex++] = [newMemo, dependencies]\n      return newMemo\n    }\n  } else { // 第一次渲染\n    let newMemo = factory()\n    hookState[hookIndex++] = [newMemo, dependencies]\n    return newMemo\n  }\n}\n\nlet App = () =>{\n  let [number, setNumber] = useState(0)\n  let [name, setName] = useState('my')\n  let data = useMemo(()=>({number}), [number])\n  let addClick = useCallback(()=> setNumber(number+1), [number])\n  return(\n    <>\n      <input value={name} onChange={(e)=> setName(e.target.value)}/>\n      <Child data={data} onButtonClick={addClick}/>\n    </>\n  )\n}\nfunction render () {\n  hookIndex = 0\n  ReactDOM.render(<App />, document.getElementById('root'));\n}\n\nrender()"]},"metadata":{},"sourceType":"module"}